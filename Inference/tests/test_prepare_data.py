
# Generated by CodiumAI

import pytest

"""
Code Analysis

Main functionalities:
The DataWrangling class is designed to prepare data for machine learning inference. It categorizes columns, renames them, adjusts data types, and limits the time frame to the last observation period. The class has several attributes that are lists of column names for different types of features.

Methods:
- prepare_data_for_inference(): This method prepares data for inference by renaming columns, categorizing columns, and adjusting data types. It then limits the time frame to the last observation period and returns the preprocessed data as well as relevant time frame information.
- _rename_columns(): This method renames columns in the given DataFrame.
- _categorize_static_categoricals(): This method categorizes static categorical columns in the given DataFrame.
- _categorize_static_reals(): This method categorizes static real valued columns in the given DataFrame.
- _categorize_time_varying_known_categoricals(): This method categorizes time varying known categorical columns in the given DataFrame.
- _categorize_time_varying_known_reals(): This method categorizes time varying known real valued columns in the given DataFrame.
- _categorize_time_varying_unknown_categoricals(): This method categorizes time varying unknown categorical columns in the given DataFrame.
- _categorize_time_varying_unknown_reals(): This method categorizes time varying unknown real valued columns in the given DataFrame.
- _categorize_columns(): This method categorizes all columns in the given DataFrame using concurrent.futures.ThreadPoolExecutor().
- _adjust_data_types(): This method adjusts the data types in the given DataFrame.
- _limit_time_frame(): This method limits the time frame to the last observation period and returns the resulting dataframe as well as relevant time frame information.

Fields:
- static_categoricals (List[str]): List of column names for static categorical features.
- static_reals (List[str]): List of column names for static numerical features.
- time_varying_known_categoricals (List[str]): List of column names for time-varying known categorical features.
- time_varying_known_reals (List[str]): List of column names for time-varying known numerical features.
- time_varying_unknown_categoricals (List[str]): List of column names for time-varying unknown categorical features.
- time_varying_unknown_reals (List[str]): List of column names for time-varying unknown numerical features.
"""

class TestDataWrangling:
    # Tests that data is preprocessed correctly for machine learning inference. 
    def test_prepare_data_for_inference_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['A', 'B', 'C'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['X', 'Y', 'Z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['M', 'N', 'O'],
            'TVUR_col6': [4.0, 5.0, 6.0]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        expected_static_categoricals = ['SC_col1']
        expected_static_reals = ['SR_col2']
        expected_time_varying_known_categoricals = ['TVKC_col3']
        expected_time_varying_known_reals = ['TVKR_col4']
        expected_time_varying_unknown_categoricals = ['TVUC_col5']
        expected_time_varying_unknown_reals = ['TVUR_col6']
        expected_data = pd.DataFrame({
            'SC_col1': ['A', 'B', 'C'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['X', 'Y', 'Z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['M', 'N', 'O'],
            'TVUR_col6': [4.0, 5.0, 6.0]
        })
        expected_last_day_we_have_data = 2
        expected_training_cutoff = -88
        expected_end_of_timeseries = 92
        result = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        assert result[0].equals(expected_data)
        assert result[1] == expected_last_day_we_have_data
        assert result[2] == expected_training_cutoff
        assert result[3] == expected_end_of_timeseries
        assert dw.static_categoricals == expected_static_categoricals
        assert dw.static_reals == expected_static_reals
        assert dw.time_varying_known_categoricals == expected_time_varying_known_categoricals
        assert dw.time_varying_known_reals == expected_time_varying_known_reals
        assert dw.time_varying_unknown_categoricals == expected_time_varying_unknown_categoricals
        assert dw.time_varying_unknown_reals == expected_time_varying_unknown_reals

    # Tests that columns are renamed correctly. 
    def test_prepare_data_for_inference_columns_renamed_correctly(self, mocker):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC.col1': ['A', 'B', 'C'],
            'SR.col2': [1.0, 2.0, 3.0],
            'TVKC.col3': ['X', 'Y', 'Z'],
            'TVKR.col4': [0, 1, 2],
            'TVUC.col5': ['M', 'N', 'O'],
            'TVUR.col6': [4.0, 5.0, 6.0]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        expected_data = pd.DataFrame({
            'SC_col1': ['A', 'B', 'C'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['X', 'Y', 'Z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['M', 'N', 'O'],
            'TVUR_col6': [4.0, 5.0, 6.0]
        })
        mocker.patch.object(logging, 'debug')
        dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        assert data.equals(expected_data)
        logging.debug.assert_called_once_with('Renaming columns')

    # Tests that an empty dataframe is handled correctly. 
    def test_prepare_data_for_inference_empty_dataframe(self):
        dw = DataWrangling()
        data = pd.DataFrame()
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        expected_data = pd.DataFrame()
        expected_last_day_we_have_data = None
        expected_training_cutoff = None
        expected_end_of_timeseries = None
        result = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        assert result[0].equals(expected_data)
        assert result[1] == expected_last_day_we_have_data
        assert result[2] == expected_training_cutoff
        assert result[3] == expected_end_of_timeseries

    # Tests that a dataframe with missing values is handled correctly. 
    def test_prepare_data_for_inference_missing_values(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['A', 'B', None],
            'SR_col2': [1.0, None, 3.0],
            'TVKC_col3': ['X', 'Y', 'Z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['M', 'N', 'O'],
            'TVUR_col6': [4.0, 5.0, 6.0]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        expected_data = pd.DataFrame({
            'SC_col1': ['A', 'B', None],
            'SR_col2': [1.0, None, 3.0],
            'TVKC_col3': ['X', 'Y', 'Z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['M', 'N', 'O'],
            'TVUR_col6': [4.0, 5.0, 6.0]
        })
        expected_last_day_we_have_data = 2
        expected_training_cutoff = -88
        expected_end_of_timeseries = 92
        result = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        assert result[0].equals(expected_data)
        assert result[1] == expected_last_day_we_have_data
        assert result[2] == expected_training_cutoff
        assert result[3] == expected_end_of_timeseries

    # Tests that logging statements are executed correctly. 
    def test_prepare_data_for_inference_logging_statements_executed_correctly(self, mocker):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC.col1': ['A', 'B', 'C'],
            'SR.col2': [1.0, 2.0, 3.0],
            'TVKC.col3': ['X', 'Y', 'Z'],
            'TVKR.col4': [0, 1, 2],
            'TVUC.col5': ['M', 'N', 'O'],
            'TVUR.col6': [4.0, 5.0, 6.0]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        mocker.patch.object(logging, 'debug')
        dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        logging.debug.assert_called_with('Renaming columns')

    # Tests that a dataframe with non-numeric values in numerical columns is handled correctly. 
    def test_prepare_data_for_inference_non_numeric_values(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['A', 'B', 'C'],
            'SR_col2': [1.0, 'two', 3.0],
            'TVKC_col3': ['X', 'Y', 'Z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['M', 'N', 'O'],
            'TVUR_col6': [4.0, 5.0, 6.0]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        expected_data = pd.DataFrame({
            'SC_col1': ['A', 'B', 'C'],

    # Tests that a dataframe with non-categorical values in categorical columns is handled correctly.  
    def test_prepare_data_for_inference_non_categorical_values(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': [1, 2, 3],
            'SR_col2': [4.5, 6.7, 8.9],
            'TVKC_col3': ['a', 'b', 'c'],
            'TVKR_col4': [1, 2, 3],
            'TVUC_col5': ['x', 'y', 'z'],
            'TVUR_col6': [4.5, 6.7, 8.9]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        preprocessed_data, _, _, _ = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        assert preprocessed_data['TVKC_col3'].dtype == 'category'
        assert preprocessed_data['TVUC_col5'].dtype == 'category'
        assert preprocessed_data['SC_col1'].dtype == int
        assert preprocessed_data['SR_col2'].dtype == float

    # Tests that the original dataframe is not modified in place.  
    def test_prepare_data_for_inference_dataframe_not_modified(self):
        # Arrange
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })
        original_data = data.copy()

        # Act
        dw.prepare_data_for_inference(data, '2022-01-01')

        # Assert
        assert data.equals(original_data)

    
    # Tests that data is preprocessed correctly for machine learning inference. 
    def test_prepare_data_for_inference_happy_path(self, mocker):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380

        # Mock
        mocker.patch.object(DataWrangling, '_rename_columns')
        mocker.patch.object(DataWrangling, '_categorize_columns')
        mocker.patch.object(DataWrangling, '_adjust_data_types')
        mocker.patch.object(DataWrangling, '_limit_time_frame')

        # Exercise
        result = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)

        # Assert
        assert isinstance(result[0], pd.DataFrame)
        assert isinstance(result[1], float)
        assert isinstance(result[2], float)
        assert isinstance(result[3], float)

    # Tests that columns are renamed correctly. 
    def test_rename_columns_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'col.1': [1, 2, 3],
            'col.2': [4, 5, 6]
        })

        # Exercise
        dw._rename_columns(data)

        # Assert
        assert list(data.columns) == ['col_1', 'col_2']

    # Tests that an empty dataframe is handled correctly. 
    def test_prepare_data_for_inference_edge_case_empty_dataframe(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame()
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380

        # Exercise
        result = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)

        # Assert
        assert isinstance(result[0], pd.DataFrame)
        assert result[0].empty
        assert isinstance(result[1], float)
        assert isinstance(result[2], float)
        assert isinstance(result[3], float)

    # Tests that a dataframe with missing values is handled correctly. 
    def test_prepare_data_for_inference_edge_case_missing_values(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', None],
            'SR_col2': [1, 2, None],
            'TVKC_col3': ['x', 'y', None],
            'TVKR_col4': [4, 5, None],
            'TVUC_col5': ['p', 'q', None],
            'TVUR_col6': [7, 8, None]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380

        # Exercise
        result = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)

        # Assert
        assert isinstance(result[0], pd.DataFrame)
        assert result[0].isnull().values.any()
        assert isinstance(result[1], float)
        assert isinstance(result[2], float)
        assert isinstance(result[3], float)

    # Tests that static categorical columns are categorized correctly. 
    def test_categorize_static_categoricals_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })

        # Exercise
        dw._categorize_static_categoricals(data)

        # Assert
        assert dw.static_categoricals == ['SC_col1']

    # Tests that static numerical columns are categorized correctly. 
    def test_categorize_static_reals_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })

        # Exercise
        dw._categorize_static_reals(data)

        # Assert
        assert dw.static_reals == ['SR_col2']

    # Tests that time-varying known categorical columns are categorized correctly. 
    def test_categorize_time_varying_known_categoricals_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })

        # Exercise
        dw._categorize_time_varying_known_categoricals(data)

        # Assert
        assert dw.time_varying_known_categoricals == ['TVKC_col3']

    # Tests that time-varying known numerical columns are categorized correctly. 
    def test_categorize_time_varying_known_reals_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })

        # Exercise
        dw._categorize_time_varying_known_reals(data)

        # Assert
        assert dw.time_varying_known_reals == ['TVKR_col4']

    # Tests that time-varying unknown categorical columns are categorized correctly. 
    def test_categorize_time_varying_unknown_categoricals_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })

        # Exercise
        dw._categorize_time_varying_unknown_categoricals(data)

        # Assert
        assert dw.time_varying_unknown_categoricals == ['TVUC_col5']

    # Tests that time-varying unknown numerical columns are categorized correctly. 
    def test_categorize_time_varying_unknown_reals_happy_path(self):
        # Setup
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })

        # Exercise
        dw._categorize_time_varying_unknown_reals(data)

        # Assert
        assert dw.time_varying_unknown_reals == ['TVUR_col6']



    # Tests that data is preprocessed correctly for machine learning inference. 
    def test_prepare_data_for_inference_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        expected_static_categoricals = ['SC_col1']
        expected_static_reals = ['SR_col2']
        expected_time_varying_known_categoricals = ['TVKC_col3']
        expected_time_varying_known_reals = ['TVKR_col4']
        expected_time_varying_unknown_categoricals = ['TVUC_col5']
        expected_time_varying_unknown_reals = ['TVUR_col6']
        expected_data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4.0, 5.0, 6.0],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7.0, 8.0, 9.0]
        })
        expected_last_day_we_have_data = 6
        expected_training_cutoff = -84
        expected_end_of_timeseries = 96
        actual_data, actual_last_day_we_have_data, actual_training_cutoff, actual_end_of_timeseries = dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)
        assert actual_data.equals(expected_data)
        assert actual_last_day_we_have_data == expected_last_day_we_have_data
        assert actual_training_cutoff == expected_training_cutoff
        assert actual_end_of_timeseries == expected_end_of_timeseries
        assert dw.static_categoricals == expected_static_categoricals
        assert dw.static_reals == expected_static_reals
        assert dw.time_varying_known_categoricals == expected_time_varying_known_categoricals
        assert dw.time_varying_known_reals == expected_time_varying_known_reals
        assert dw.time_varying_unknown_categoricals == expected_time_varying_unknown_categoricals
        assert dw.time_varying_unknown_reals == expected_time_varying_unknown_reals

    # Tests that columns are renamed correctly. 
    def test_rename_columns_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'col.1': [1, 2, 3],
            'col.2': [4, 5, 6]
        })
        expected_data = pd.DataFrame({
            'col_1': [1, 2, 3],
            'col_2': [4, 5, 6]
        })
        dw._rename_columns(data)
        assert data.equals(expected_data)

    # Tests that an empty dataframe is handled correctly. 
    def test_prepare_data_for_inference_edge_case_empty_dataframe(self):
        dw = DataWrangling()
        data = pd.DataFrame()
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        with pytest.raises(Exception):
            dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)

    # Tests that a dataframe with missing values is handled correctly. 
    def test_prepare_data_for_inference_edge_case_missing_values(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'col1': [1, 2, None],
            'col2': [4, 5, 6]
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380
        with pytest.raises(Exception):
            dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)

    # Tests that static categorical columns are categorized correctly. 
    def test_categorize_static_categoricals_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3]
        })
        expected_static_categoricals = ['SC_col1']
        dw._categorize_static_categoricals(data)
        assert dw.static_categoricals == expected_static_categoricals

    # Tests that static numerical columns are categorized correctly. 
    def test_categorize_static_reals_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3]
        })
        expected_static_reals = ['SR_col2']
        dw._categorize_static_reals(data)
        assert dw.static_reals == expected_static_reals

    # Tests that time-varying known categorical columns are categorized correctly. 
    def test_categorize_time_varying_known_categoricals_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'TVKC_col1': ['a', 'b', 'c'],
            'TVKR_col2': [1, 2, 3]
        })
        expected_time_varying_known_categoricals = ['TVKC_col1']
        dw._categorize_time_varying_known_categoricals(data)
        assert dw.time_varying_known_categoricals == expected_time_varying_known_categoricals

    # Tests that time-varying known numerical columns are categorized correctly. 
    def test_categorize_time_varying_known_reals_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'TVKC_col1': ['a', 'b', 'c'],
            'TVKR_col2': [1, 2, 3]
        })
        expected_time_varying_known_reals = ['TVKR_col2']
        dw._categorize_time_varying_known_reals(data)
        assert dw.time_varying_known_reals == expected_time_varying_known_reals

    # Tests that data types are adjusted correctly. 
    def test_adjust_data_types_happy_path(self):
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9]
        })
        expected_data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4.0, 5.0, 6.0],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7.0, 8.0, 9.0]
        })
        dw.static_categoricals = ['SC_col1']
        dw.static_reals = ['SR_col2']
        dw.time_varying_known_categoricals = ['TVKC_col3']
        dw.time_varying_known_reals = ['TVKR_col4']
        dw.time_varying_unknown_categoricals = ['TVUC_col5']
        dw.time_varying_unknown_reals = ['TVUR_col6']
        dw._adjust_data_types(data)
        assert data.equals(expected_data)

    
    # Tests that the data is preprocessed correctly for machine learning inference, columns are renamed correctly, categorical and numerical columns are categorized correctly, data types are adjusted correctly, and time frame is limited correctly. 
    def test_prepare_data_for_inference_happy_path(self):
        # Given
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [4.0, 5.0, 6.0],
            'TVKC_daydate': ['2022-01-01', '2022-01-01', '2022-01-02']
        })
        last_observation_day = '2022-01-02'
        max_prediction_length = 1
        max_encoder_length = 3

        # When
        preprocessed_data, last_day, training_cutoff, end_of_timeseries = dw.prepare_data_for_inference(
            data, last_observation_day, max_prediction_length, max_encoder_length
        )

        # Then
        assert preprocessed_data.equals(pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1.0, 2.0, 3.0],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [4.0, 5.0, 6.0],
            'TVKC_daydate': ['2022-01-01', '2022-01-01', '2022-01-02']
        }))
        assert last_day == 2
        assert training_cutoff == 1
        assert end_of_timeseries == 3

    # Tests that an empty dataframe is handled correctly and an exception is raised. 
    def test_prepare_data_for_inference_empty_dataframe(self):
        """
        Given an empty dataframe
        When prepare_data_for_inference is called
        Then an exception is raised
        """
        dw = DataWrangling()
        data = pd.DataFrame()
        last_observation_day = "2022-01-01"
        with pytest.raises(Exception):
            dw.prepare_data_for_inference(data, last_observation_day)

    # Tests that a dataframe with missing values is handled correctly and an exception is raised.  
    def test_prepare_data_for_inference_missing_values(self):
        # Given
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 3],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [4, 5, 6],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [7, 8, 9],
            'TVKC_daydate': ['2022-01-01', '2022-01-01', '2022-01-02'],
            'TVKR_time_idx': [1, 2, 1]
        })
        data.loc[1, 'SR_col2'] = None
        last_observation_day = '2022-01-02'

        # When/Then
        with pytest.raises(ValueError):
            dw.prepare_data_for_inference(data, last_observation_day)

    # Tests that a dataframe with non-numeric values in numerical columns is handled correctly and an exception is raised. 
    def test_prepare_data_for_inference_non_numeric_values(self):
        # Given
        dw = DataWrangling()
        data = pd.DataFrame({
            'SC_col1': ['a', 'b', 'c'],
            'SR_col2': [1, 2, 'three'],
            'TVKC_col3': ['x', 'y', 'z'],
            'TVKR_col4': [0, 1, 2],
            'TVUC_col5': ['p', 'q', 'r'],
            'TVUR_col6': [3.14, 2.71, 'pi']
        })
        last_observation_day = '2022-01-01'
        max_prediction_length = 90
        max_encoder_length = 380

        # When, Then
        with pytest.raises(ValueError):
            dw.prepare_data_for_inference(data, last_observation_day, max_prediction_length, max_encoder_length)